// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package kafka.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import kafka.impl.KafkaProducerRepository;
import kafka.impl.KafkaPropertiesFactory;
import kafka.proxies.Header;
import org.apache.kafka.clients.producer.*;
import com.mendix.systemwideinterfaces.core.IMendixObject;

/**
 * Sends ('produces') a message in a Kafka topic.
 * 
 * Before using this action, make sure a producer with this name has been stared using the StartProducer action.
 * 
 * This action will always return true.
 */
public class SendAsynchronous extends CustomJavaAction<java.lang.Boolean>
{
	/** @deprecated use producer.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __producer;
	private final kafka.proxies.Producer producer;
	private final java.lang.String topic;
	private final java.lang.String key;
	private final java.lang.String value;
	/** @deprecated use com.mendix.utils.ListUtils.map(headers, com.mendix.systemwideinterfaces.core.IEntityProxy::getMendixObject) instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final java.util.List<IMendixObject> __headers;
	private final java.util.List<kafka.proxies.Header> headers;
	private final java.lang.Boolean useCachedProducer;

	public SendAsynchronous(
		IContext context,
		IMendixObject _producer,
		java.lang.String _topic,
		java.lang.String _key,
		java.lang.String _value,
		java.util.List<IMendixObject> _headers,
		java.lang.Boolean _useCachedProducer
	)
	{
		super(context);
		this.__producer = _producer;
		this.producer = _producer == null ? null : kafka.proxies.Producer.initialize(getContext(), _producer);
		this.topic = _topic;
		this.key = _key;
		this.value = _value;
		this.__headers = _headers;
		this.headers = java.util.Optional.ofNullable(_headers)
			.orElse(java.util.Collections.emptyList())
			.stream()
			.map(headersElement -> kafka.proxies.Header.initialize(getContext(), headersElement))
			.collect(java.util.stream.Collectors.toList());
		this.useCachedProducer = _useCachedProducer;
	}

	@java.lang.Override
	public java.lang.Boolean executeAction() throws Exception
	{
		// BEGIN USER CODE
		KafkaProducer<String, String>  kafkaProducer;
		
		if (useCachedProducer) {
			kafkaProducer = KafkaProducerRepository.get(producer.getName());
		} else {
			kafkaProducer = new KafkaProducer<String, String>(
					KafkaPropertiesFactory.getKafkaProperties(getContext(), producer));
		}

		ProducerRecord<String, String> record;
		if (key == null || key.isEmpty()) {
			record = new ProducerRecord<String, String>(topic, value);
		} else {
			record = new ProducerRecord<String, String>(topic, key, value);
		}
		
		for (Header header : this.headers) {
			record.headers().add(header.getKey(), header.getValue().getBytes());
		}
		
		kafkaProducer.send(record);
		
		if (!useCachedProducer) {
			// if the cache is not used, Producers are created every time we call this JA
			// and they must be closed; unclosed Producers communicate with the broker every 60s 
			// to re-authenticate; for more information see sasl.kerberos.min.time.before.relogin
			kafkaProducer.close();
		}
		
		return true;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "SendAsynchronous";
	}

	// BEGIN EXTRA CODE
	// END EXTRA CODE
}
